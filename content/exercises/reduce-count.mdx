---
title: "Count Occurrences with reduce()"
slug: "reduce-count"
category: "array"
method: "reduce"
---

# Count Occurrences with reduce()

### Problem
Write a function that uses `reduce` to count how many times each value appears in an array.

### Example
```js
Input: ["a", "b", "a", "c", "b", "a"]
Output: { "a": 3, "b": 2, "c": 1 }
```

### Requirements
1. Use Array.prototype.reduce()
2. Return an object with the counts
3. If the array is empty, return an empty object

## Education

### Building Objects with reduce()

## Core Concept
`reduce()` can build complex objects by accumulating data in each iteration.

## Object Counting Pattern
```js
array.reduce((counts, item) => {
  counts[item] = (counts[item] || 0) + 1;
  return counts;
}, {})
```

## How It Works
1. **Start Empty**: Begin with `{}` as initialValue
2. **Update Counts**: For each item:
   - Get current count (or 0 if new)
   - Increment count by 1
   - Store back in accumulator
3. **Return Object**: Final accumulator has all counts

## Why This Pattern?
- Single pass through data
- Automatic key creation
- Memory efficient
- Easy to extend logic

### Visual Example

## Visual Process

```js
["a", "b", "a"].reduce((acc, curr) => {
  acc[curr] = (acc[curr] || 0) + 1;
  return acc;
}, {})
```

### Step-by-Step:
```text
Initial state: {}

Process "a":
   {} → { a: 1 }

Process "b":
   { a: 1 } → { a: 1, b: 1 }

Process "a":
   { a: 1, b: 1 } → { a: 2, b: 1 }

Result: { a: 2, b: 1 }
```


### Common Use Cases

- **Word Frequency**: `words.reduce((freq, word) => ({ ...freq, [word]: (freq[word] || 0) + 1 }), {})`
- **Tag Counting**: Analyzing most common categories/tags
- **User Activity**: Tracking action frequencies per user
- **Data Analysis**: Preparing data for charts/graphs

### Common Mistakes to Avoid

- **Mutating Without Return**: Forgetting to return the accumulator
- **No Initial Value**: Not providing `{}` as initialValue
- **Type Issues**: Not handling mixed data types properly


### Pro Tips

- **Use Nullish Coalescing**: `counts[item] ??= 0` for cleaner initialization
- **Consider Map**: Use `Map` for non-string keys
- **Immutable Update**: Use spread operator for immutable updates if needed


## Starter Code

```javascript
const solve = (items) => {
  // Use reduce to build an object of counts
  // Start with {} as initialValue
  return {}; // Replace with your logic
}
```

## Test Cases

### Test 1

- **Input:** `[["a","b","a","c","b","a"]]`
- **Expected:** `{"a":3,"b":2,"c":1}`
- **Description:** Should count `a: 3`, `b: 2`, `c: 1` correctly

### Test 2

- **Input:** `[["x","x","x"]]`
- **Expected:** `{"x":3}`
- **Description:** Should count three `x`s as `{ x: 3 }`

### Test 3

- **Input:** `[[]]`
- **Expected:** `{}`
- **Description:** Should return empty object `{}` for empty array

### Test 4

- **Input:** `[["unique"]]`
- **Expected:** `{"unique":1}`
- **Description:** Should count single item as `{ unique: 1 }`

### Test 5

- **Input:** `[[1,1,2]]`
- **Expected:** `{"1":2,"2":1}`
- **Description:** Should count numeric values
